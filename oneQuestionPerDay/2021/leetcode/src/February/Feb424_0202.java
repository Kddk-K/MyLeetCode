package February;

/**
 * 424. 替换后的最长重复字符      难度：medium
 *
 * 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，
 * 找到包含重复字母的最长子串的长度。
 * 注意：字符串长度 和 k 不会超过 104。
 *
 * 示例 1：
 * 输入：s = "ABAB", k = 2
 * 输出：4
 * 解释：用两个'A'替换为两个'B',反之亦然。
 *
 * 示例 2：
 * 输入：s = "AABABBA", k = 1
 * 输出：4
 * 解释：
 * 将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
 * 子串 "BBBB" 有最长重复字母, 答案为 4。
 *
 */

//思路：我们这里可以利用双指针维护一个区间，也就是滑动窗口。使得这个区间内一定可以组成一个连续字符串。
//首先，因为字符限制在26个，所以我们可以枚举所有字符作为连续字符串的情况；
//然后，利用一个计数值来统计当前区间枚举的字符个数，那么其他字符个数就是区间长度减去这个计数值；
//其中，去过其他字符数量大于k，说明这个区间无法组成以当前字符为连续字符串，那么就需要缩小区间的大小，直到满足可以组成连续字符串的情况；
//最后，将答案和区间长度取最大值。

public class Feb424_0202 {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int res = Math.min(k, n);
        for(char c = 'A'; c <= 'Z'; c++){
            int count = 0;
            for(int i = 0, j = 0; i < n; i++){
                if(s.charAt(i) == c){
                    count++;
                }
                /**
                 * i:后指针;   j:前指针
                 * i-j+1:从j到i的总字符数
                 * count:已遍历的相同的字符数
                 * i-j+1-count:其余的个数，若<k就代表能交换，>k则不行，将后指针+1,维持窗口的最大值
                 */
                while(i - j + 1 - count > k){
                    if(s.charAt(j) == c){
                        count--;
                    }
                    j++;
                }
                res = Math.max(res, i - j + 1);

            }
        }
        return res;
    }
}
